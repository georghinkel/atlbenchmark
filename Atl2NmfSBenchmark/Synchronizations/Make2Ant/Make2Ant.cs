//------------------------------------------------------------------------------
// <auto-generated>
//     This Code was automatically created by the Atl2NmfS higher-order transformation.
//
//     Changes to this file can result in a wrong behavior and are discarded if the code is generated again.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Globalization;
using NMF.Expressions.Linq;
using NMF.Synchronizations;
using NMF.Transformations;
using NMF.Utilities;
using NMF.Models;

namespace Make2AntNamespace
{
    public partial class Make2Ant : ReflectiveSynchronization
    {
        public Make2Ant(InputModelContainer inputModelContainer, OutputModelContainer outputModelContainer)
        {
            InputModelContainer = inputModelContainer;
            OutputModelContainer = outputModelContainer;
        }
    	
    	public static InputModelContainer InputModelContainer { get; set; }
    	
    	public static OutputModelContainer OutputModelContainer { get; set; }
    	
    	public partial class Model2ModelMainRule : SynchronizationRule<InputModelContainer, OutputModelContainer>
    	{
    		public override bool ShouldCorrespond(InputModelContainer left, OutputModelContainer right, ISynchronizationContext context)
    		{
    			return true;
    		}
    		
    	    public override void DeclareSynchronization()
    	    {
    	    	SynchronizeManyLeftToRightOnly(SyncRule<Makefile2Project>(),
    	    		input => input.IN.Descendants().OfType<Make.IMakefile>(),
    	    		output => new OutputModelCollection<Ant.IProject>(output.OUT.RootElements.OfType<IModelElement, Ant.IProject>()));
    	    	
    	    	SynchronizeManyLeftToRightOnly(SyncRule<Macro2Property>(),
    	    		input => input.IN.Descendants().OfType<Make.IMacro>(),
    	    		output => new OutputModelCollection<Ant.IPropertyValue>(output.OUT.RootElements.OfType<IModelElement, Ant.IPropertyValue>()));
    	    	
    	    	SynchronizeManyLeftToRightOnly(SyncRule<Rule2Target>(),
    	    		input => input.IN.Descendants().OfType<Make.IRule>(),
    	    		output => new OutputModelCollection<Ant.ITarget>(output.OUT.RootElements.OfType<IModelElement, Ant.ITarget>()));
    	    	
    	    	SynchronizeManyLeftToRightOnly(SyncRule<ShellLine2Task_Display>(),
    	    		input => input.IN.Descendants().OfType<Make.IShellLine>().Where(x => x.ShellLine2Task_DisplayFilter()),
    	    		output => new OutputModelCollection<Ant.IEcho>(output.OUT.RootElements.OfType<IModelElement, Ant.IEcho>()));
    	    	
    	    	SynchronizeManyLeftToRightOnly(SyncRule<ShellLine2Task_DisplayX>(),
    	    		input => input.IN.Descendants().OfType<Make.IShellLine>().Where(x => x.ShellLine2Task_DisplayFilter()),
    	    		output => new OutputModelCollection<Ant.IExec>(output.OUT.RootElements.OfType<IModelElement, Ant.IExec>()));
    	    	
    	    	SynchronizeManyLeftToRightOnly(SyncRule<ShellLine2Task_NoDisplay>(),
    	    		input => input.IN.Descendants().OfType<Make.IShellLine>().Where(x => x.ShellLine2Task_NoDisplayFilter()),
    	    		output => new OutputModelCollection<Ant.IExec>(output.OUT.RootElements.OfType<IModelElement, Ant.IExec>()));
    	    }
    	}
    	
    	public partial class Makefile2Project : SynchronizationRule<Make.IMakefile, Ant.IProject>
    	{
    	    public override void DeclareSynchronization()
    	    {
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.Name,
    	    		a => a.Name);
    	    	
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.Comment.Text,
    	    		a => a.Description);
    	    	
    	    	SynchronizeManyLeftToRightOnly(SyncRule<Macro2Property>(),
    	    		m => m.Elements.OfType<Make.IMacro>(),
    	    		a => a.Properties.OfType<Ant.IProperty, Ant.IPropertyValue>());
    	    	
    	    	SynchronizeManyLeftToRightOnly(SyncRule<Rule2Target>(),
    	    		m => m.Elements.OfType<Make.IRule>(),
    	    		a => a.Targets);
    	    	
    	    	SynchronizeLeftToRightOnly(SyncRule<Rule2Target>(),
    	    		m => m.Elements.OfType<Make.IRule>().FirstOrDefault(),
    	    		a => a.Default,
    	    		null);
    	    	
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.ID + "a0",
    	    		a => a.ID);
    	    }
    	}
    	
    	public partial class Macro2Property : SynchronizationRule<Make.IMacro, Ant.IPropertyValue>
    	{
    	    public override void DeclareSynchronization()
    	    {
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.Name,
    	    		a => a.Name);
    	    	
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.Value,
    	    		a => a.Value);
    	    	
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.ID + "a1",
    	    		a => a.ID);
    	    }
    	}
    	
    	public partial class Rule2Target : SynchronizationRule<Make.IRule, Ant.ITarget>
    	{
    	    public override void DeclareSynchronization()
    	    {
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.Name,
    	    		a => a.Name);
    	    	
    	    	SynchronizeManyLeftToRightOnly(SyncRule<ShellLine2Task_Display>(),
    	    		m => m.ShellLines.Where(x => x.ShellLine2Task_DisplayFilter()),
    	    		a => a.Tasks.OfType<Ant.ITask, Ant.IEcho>());
    	    	
    	    	SynchronizeManyLeftToRightOnly(SyncRule<ShellLine2Task_NoDisplay>(),
    	    		m => m.ShellLines.Where(x => x.ShellLine2Task_NoDisplayFilter()),
    	    		a => a.Tasks.OfType<Ant.ITask, Ant.IExec>());
    	    	
    	    	SynchronizeManyLeftToRightOnly(SyncRule<Rule2Target>(),
    	    		m => m.Dependencies.OfType<Make.IRuleDep>().Select(e => e.Ruledep),
    	    		a => a.Depends);
    	    	
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.ID + "a2",
    	    		a => a.ID);
    	    }
    	}
    	
    	public partial class ShellLine2Task_Display : SynchronizationRule<Make.IShellLine, Ant.IEcho>
    	{
    	    public override void DeclareSynchronization()
    	    {
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.Command,
    	    		e => e.Message);
    	    	
    	    	SynchronizeLeftToRightOnly(SyncRule<Rule2Target>(),
    	    		m => m.RuleShellLine,
    	    		e => e.Target,
    	    		null);
    	    	
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.ID + "a3",
    	    		e => e.ID);
    	    }
    	}
    	
    	public partial class ShellLine2Task_DisplayX : SynchronizationRule<Make.IShellLine, Ant.IExec>
    	{
    	    public override void DeclareSynchronization()
    	    {
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.Command,
    	    		x => x.Executable);
    	    	
    	    	SynchronizeLeftToRightOnly(SyncRule<Rule2Target>(),
    	    		m => m.RuleShellLine,
    	    		x => x.Target,
    	    		null);
    	    	
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.ID + "a4",
    	    		x => x.ID);
    	    }
    	}
    	
    	public partial class ShellLine2Task_NoDisplay : SynchronizationRule<Make.IShellLine, Ant.IExec>
    	{
    	    public override void DeclareSynchronization()
    	    {
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.Command,
    	    		x => x.Executable);
    	    	
    	    	SynchronizeLeftToRightOnly(SyncRule<Rule2Target>(),
    	    		m => m.RuleShellLine,
    	    		x => x.Target,
    	    		null);
    	    	
    	    	SynchronizeLeftToRightOnly(
    	    		m => m.ID + "a5",
    	    		x => x.ID);
    	    }
    	}
    }
}
